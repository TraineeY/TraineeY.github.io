<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[实习日记-Round1]]></title>
      <url>http://yoursite.com/2016/08/08/%E5%AE%9E%E4%B9%A0%E6%97%A5%E8%AE%B0-Round1/</url>
      <content type="html"><![CDATA[<p>Trainee Diary–Round  1：Hey，fish！<br>入职第一天，一秒变小鱼人，再也不是在预言家查杀下笑着活下去精钢狼了。<br>开一个专栏，看看一年后回过头我是有长进还是有长进吧。<br><a id="more"></a></p>
<h2 id="入职前一小时"><a href="#入职前一小时" class="headerlink" title="入职前一小时"></a>入职前一小时</h2><p>学化学的学长每天摸10小时烧杯，今年已经有2年java开发经验。<br>学计算机的我每天12个小时抱着电脑，现在只是实习生。</p>
<h2 id="入职一小时"><a href="#入职一小时" class="headerlink" title="入职一小时"></a>入职一小时</h2><p>等着分不清的某部门的师兄来装电脑，再看看书包里100公斤的小老婆–斯丢批德。<br>一群大男人对着新配的i7和高半头的屏幕羡慕恨，这种基本追求大概程序员是戒不掉了。</p>
<h2 id="高师傅"><a href="#高师傅" class="headerlink" title="高师傅"></a>高师傅</h2><p>钟老板介绍的师傅姓高，听口音是老员工了。<br>静一静，静一静，你听师傅和你说啊：从前呢<br>先从业务流程讲，现在公司并行有两套系统，一套是第三方支付-泰易付-泰和网，一套是8.15要上线的银行-泰易付-泰然城，要被监管了，所以第三方支付要转向银行。<br>讲数据库</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[core-java-初始化]]></title>
      <url>http://yoursite.com/2016/07/25/core-java-%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>java尽力保证：所有变量在使用之前都能得到恰当的初始化。<br><a id="more"></a></p>
<h2 id="初始化的变量"><a href="#初始化的变量" class="headerlink" title="初始化的变量"></a>初始化的变量</h2><p>需要初始化的变量分为局部变量和成员变量（即数据成员、字段）。<br><strong>局部变量：</strong>在定义后，使用前需要程序员赋初始值，不然使用该变量时会报错。<br><strong>成员变量：</strong>在定义时编译器根据不同的数据类型会给不同的默认值（基本数据类型中，boolean为false，其它为0，其中char为0时显示空白‘【】’，对象引用初始值为null）。</p>
<blockquote>
<p>编译器不会给局部变量赋默认值，因为局部变量未初始化通常是程序员喝了假酒，采用默认值反而会掩盖这种失误，所以强制程序员自己赋值，这样往往可以减少bug。</p>
</blockquote>
<h2 id="初始化的方式"><a href="#初始化的方式" class="headerlink" title="初始化的方式"></a>初始化的方式</h2><h3 id="指定初始化"><a href="#指定初始化" class="headerlink" title="指定初始化"></a>指定初始化</h3><p>即在定义的时候给变量赋值</p>
<pre><code>int i=1;
char c=&apos;c&apos;;
String str=&quot;HELLO KITTY!&quot;
</code></pre><h3 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h3><p>构造器可以简单看成一个以类名为名称的没有返回值的方法。</p>
<pre><code>public class Test {
    int i;
    Test(){
        i=1;
    }
}
</code></pre><h3 id="代码块初始化"><a href="#代码块初始化" class="headerlink" title="代码块初始化"></a>代码块初始化</h3><p>这里分为显示的静态初始化和非静态实例初始化。<br><strong>显示静态初始化：</strong>许多静态初始化动作的集合（静态块）</p>
<pre><code>static int i;
static double j;
static{
    i=1;
    j=1.0;
}
</code></pre><p><strong>非静态实例初始化：</strong>与初始化一系列静态对象类似的语句块</p>
<pre><code>int i;
double j;
{
    i=1;
    j=1.0;
}
</code></pre><p>两者的区别看起来区别只在于初始化的对象是否为静态的，需要说明的是非静态实例初始化对于支持匿名内部类的初始化是必须的。</p>
<blockquote>
<p>静态初始化只在类对象首次加载（首次创建类对象或者类的静态方法/静态域首次被访问）时初始化一次。<br>实例初始化在每次构造器被调用前都会执行。</p>
</blockquote>
<h2 id="初始化的顺序"><a href="#初始化的顺序" class="headerlink" title="初始化的顺序"></a>初始化的顺序</h2><p>局部变量在程序员给它赋值的时候初始化。<br>成员变量在声明时，编译器先给它一个默认初始值，如果有继承关系,先执行基类构造器，再执行字段定义处的动作（包括代码块的初始化），最后执行子类构造器。如：</p>
<pre><code>public class FatherOfTest {
int i;        
FasterOfTest(){
        i=1;
    }
public class Test {
    {
        i=2;
    }
    Test(){
        i=3;
    }
}
</code></pre><p>因为i为int类型，i先得到默认初始值0，再执行基类的构造器初始化为1，再执行代码块赋值为2，再由子类构造器赋值为3.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[core-java内部类]]></title>
      <url>http://yoursite.com/2016/07/19/core-java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>人家都叫内部类那就是说她是定义在另一个类中的类咯。<br><a id="more"></a></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>内部类又分为成员内部类、静态内部类、方法内部类和匿名内部类。<br>使用内部类的主要原因：</p>
<ol>
<li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据</li>
<li>内部类可以对同一个包的其他类隐藏起来</li>
<li>想定义一个回调函数又不想编写大量代码，使用匿名内部类比较便捷</li>
</ol>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><pre><code>class Outer {
    class Inner{

    }
}
</code></pre><p>在外部类Outer中声明了一个内部类Inner，编译以后会产生两个.class文件：Outer.class和Outer$Inner.class。</p>
<h2 id="方法内部类"><a href="#方法内部类" class="headerlink" title="方法内部类"></a>方法内部类</h2><pre><code>class Outer {
    public void f(){
        class Inner{

        }
    }    
}
</code></pre><p>在代码块如一个方法中创建的内部类即方法内部类（局部内部类）。</p>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><pre><code>class OtherClass{
    private int n;
    public OuherClass(int x){
        n=x;
    }
}
class Outer {
    public OtherClass f(int x){
        return new OtherClass(x){
            private int i=1;
            private int j;
            {j=2;}//实例初始化
        };
    }    
}
</code></pre><p>在外部类Outer中有一个方法f()，return语句表达的是<strong>返回一个继承自OtherClass的匿名类对象</strong>，new表达式将返回的引用向上转型为对OtherClass的引用。<br>内部类的初始化可以通过传参数给基类OtherClass的构造器完成，或者在定义字段中完成。<br>匿名内部类没有名字所以没有构造器，可以通过实例初始化达到类似构造器的目的。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><pre><code>class Outer {
    static class Inner{

    }
}
</code></pre><p>普通内部类隐式地保存一个指向创建它的外部类的对象，而静态内部类（又叫嵌套类）没有，所以不需要内部类对象和外部类对象有什么联系可以将内部类声明为static。</p>
<ol>
<li>创建静态内部类对象不需要外围类对象。</li>
<li>不能从静态内部类对像中访问非静态的外部类对象。</li>
</ol>
<h3 id="接口内部的类"><a href="#接口内部的类" class="headerlink" title="接口内部的类"></a>接口内部的类</h3><p>由于接口中的任何类自动为public和static，所以接口中可以有静态内部类，可用于创建某些公共代码给这个接口的不同实现共用。</p>
<blockquote>
<p>嵌套类可以用来放置测试代码，这样发布产品是可以简单的删除Outer$Inner.class而不必带着编译过的额外代码。</p>
</blockquote>
<p>更多内容请看下集。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[github pages+hexo的个人博客搭建]]></title>
      <url>http://yoursite.com/2016/07/10/github-pages+hexo%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p><strong>摘要：</strong><br>从清清白白一个人到完完整整一个个人博客的搭建过程，主要说一下会碰到的问题。自己梳理的同时，也给后面有兴趣自己搭建博客的庞游一个参考。文末会给出一些深入学习的资料链接。<br><a id="more"></a></p>
<h2 id="一-环境准备："><a href="#一-环境准备：" class="headerlink" title="一. 环境准备："></a>一. 环境准备：</h2><ol>
<li><a href="https://github.com/" title="github" target="_blank" rel="external">github</a>账号一枚</li>
<li><a href="https://git-scm.com/" title="git" target="_blank" rel="external">Git</a>安装</li>
<li><a href="https://nodejs.org/en/https://nodejs.org/en/" title="node.js" target="_blank" rel="external">Node.js</a>安装</li>
</ol>
<p>注册和安装的过程就不详细写了，毕竟大家都是成年人了。</p>
<blockquote>
<p>git是一个版本控制工具<br>github是一个面向开源及私有软件项目的托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名GitHub。（就是一个存放用git管理的各种项目的远程仓库）</p>
</blockquote>
<h2 id="二-开始搭建"><a href="#二-开始搭建" class="headerlink" title="二. 开始搭建"></a>二. 开始搭建</h2><h3 id="配置SSH-keys–右键启动Git-Bash"><a href="#配置SSH-keys–右键启动Git-Bash" class="headerlink" title="配置SSH keys–右键启动Git Bash"></a>配置SSH keys–右键启动Git Bash</h3><p> <strong>查看是否有本地SSH Keys</strong></p>
<pre><code>$ cd ~/. ssh
</code></pre><p>没有会提示：No such file or directory<br> <strong>创建本地SSH Keys</strong></p>
<pre><code>$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;
</code></pre><ul>
<li>注意C要大写。</li>
<li>后面的your_email@youremail.com改为你在github上注册的邮箱</li>
</ul>
<p>之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。<br> <strong>复制刚生成的Key</strong></p>
<pre><code>$ clip &lt; ~/.ssh/id_rsa.pub
</code></pre><p><strong>配置SSH</strong></p>
<ul>
<li>登陆github系统。点击右上角的 Account Settings–&gt;SSH Public keys –&gt; Add SSH Key</li>
<li>title可以用来区分这是为哪台PC添加的SSH，正文粘贴刚复制key。</li>
</ul>
<p><strong>测试链接</strong></p>
<pre><code>$ ssh -T git@github.com
</code></pre><ul>
<li>会提示Are you sure you want to continue connecting (yes/no)? 输入yes就好了</li>
<li>最后提示Hi username! You’ve successfully authenticated, but GitHub does not…就成功了。</li>
</ul>
<p>到此SSH Keys就配置好了。</p>
<h3 id="在github上建立仓库"><a href="#在github上建立仓库" class="headerlink" title="在github上建立仓库"></a>在github上建立仓库</h3><p><strong>建立新仓库</strong><br>进入github.com，登陆后点击绿色按钮「New Repository」<br><strong>填写仓库信息</strong><br>project name：your_github_name.github.io<br>description： Writing 1000 Words a Day Changed My Life</p>
<ul>
<li>Github Pages的Repository名字是特定的，比如我Github账号是TraineeY，那么我Github Pages Repository名字就是TraineeY.github.io。</li>
</ul>
<p><strong>完成创建</strong><br>点击「Create Repository」 完成创建。</p>
<h3 id="使用HEXO"><a href="#使用HEXO" class="headerlink" title="使用HEXO"></a>使用HEXO</h3><p><strong>clone新仓库到本地</strong><br>在想要用来保存项目的目录下右键启动Git Bash</p>
<pre><code>$ git clone git@github.com:TraineeY/TraineeY.github.io.git
</code></pre><p><strong>安装hexo</strong></p>
<pre><code>$ npm install -g hexo
</code></pre><p><strong>初始化hexo到指定目录folder</strong></p>
<pre><code>$ hexo init &lt;folder&gt;
</code></pre><p>也可以cd到指定目录再执行hexo init<br><strong>启动本地服务，进行文章的预览</strong></p>
<pre><code>$ hexo server
</code></pre><p>浏览器输入 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 就可以看到效果。有一篇helloworld的例子文章。<br><strong>生成网页并部署到Github</strong><br>生成静态页面</p>
<pre><code>$ hexo generate
</code></pre><p>要部署到github还要修改_config.yml文件的deploy参数</p>
<ul>
<li>配置——config.yml文件有一个格式问题，就是：后面是有一个空格的，如下</li>
<li>deploy:</li>
<li>type: git</li>
<li>repo: git@github.com:cnfeat/cnfeat.github.io.git</li>
<li>branch: master</li>
</ul>
<p>部署到Github</p>
<pre><code>$ hexo deploy
</code></pre><p><strong>新建文章，名称为“postName”</strong></p>
<pre><code>$ hexo new “postName”
</code></pre><p>文章会储存在\source_posts\postName.md，用编辑器打开.md文件就可以写Blog了。<br><strong>安装主题</strong><br>可以到<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">github themes</a>选喜欢的主题<br>比如喜欢主题pacman，安装</p>
<pre><code>$ git clone https://github.com/A-limon/pacman.git themes/pacman
</code></pre><p>启用主题</p>
<ul>
<li>到主目录的config.yml中将theme属性值改为要使用的主题名称：theme=pacman</li>
</ul>
<p>更新主题</p>
<pre><code>$ cd themes/jacman
$ git pull
</code></pre><p>不同的主题分离出来的配置内容会有不同，所以选择一个好看又好用的主题是个比较重要的事情。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">git学习</a><br><a href="http://www.worldhello.net/gotgithub/index.html" target="_blank" rel="external">github学习</a><br><a href="http://wowubuntu.com/markdown/basic.html" target="_blank" rel="external">markdown语法</a></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>一个博客基本就出来了，后续还可以添加一些插件，比如评论功能，流量统计等等，等我熟悉了再记录。<br>最后再次感谢趟坑期间网上分享经验的庞友和开源社区。</p>
]]></content>
    </entry>
    
  
  
</search>
